package infer;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.attribute.BasicFileAttributes;
import java.nio.file.StandardCopyOption;
import java.nio.file.FileAlreadyExistsException;
import java.nio.file.Files;
import java.nio.file.FileVisitResult;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/*
Infer can call a custom compiler as long as it is implemented as a jar file,
using the (undocumented?) option --java-jar-compiler. The current class is
intended to be used as a 'compiler' that
  1. calls javac and save its stderr
    - hijack output to a temporary directory (outDir)
  2. calls toplc to instrument the classes generated by javac
    - mv outDir inDir  (where inDir is another temp dir)
    - toplc -s -i inDir -o outDir props.topl
  3. prints the stderr produced in step (1) by javac.
    - also fake Property.java and Property.class (in outDir)
*/
public class Compile {
  public static void main(String[] args)
  {
    try { go(args); }
    catch (Exception e) {
      e.printStackTrace();
      bail("Exception.");
    }
  }

  static void go(String[] args) throws IOException, InterruptedException {
    // === Step 1 ===
    List<String> toplProperties = new ArrayList<>();
    List<String> javacArgs = expandArgFile(args);
    { List<String> xs = new ArrayList<>();
      for (String a : javacArgs) {
        // FIXME: use some better hack for distinguishing options?
        if (a.endsWith(".topl")) {
          toplProperties.add(a);
        } else {
          xs.add(a);
        }
      }
      javacArgs = xs;
    }

    { String outDirName = null;
      boolean previousIsD = false;
      List<String> xs = new ArrayList<>();
      for (String a : javacArgs) {
        if (previousIsD) {
          outDirName = a;
          previousIsD = false;
        } else if ("-d".equals(a)) {
          previousIsD = true;
        } else {
          xs.add(a);
        }
      }
      javacArgs = xs;
      if (outDirName != null) {
        System.out.printf("W: ignoring original -d (%s)\n", outDirName);
      }
    }

    File javacErr = File.createTempFile("topljavac", "stderr");
    Path outDirPath = Files.createTempDirectory("topljavac-out");
    Path inDirPath = Files.createTempDirectory("topljavac-in");

    { List<String> javacCommand = new ArrayList<>();
      javacCommand.add("javac");
      javacCommand.addAll(javacArgs);
      javacCommand.add("-d");
      javacCommand.add(outDirPath.toString());
      ProcessBuilder javacBuilder = new ProcessBuilder(javacCommand);
      javacBuilder.redirectError(javacErr);
      Process javac = javacBuilder.start();
      int result = javac.waitFor();
      if (result != 0) bail("javac returned nonzero error code");
    }

    // === Step 2 ===
    { Files.delete(inDirPath);
      Files.move(outDirPath, inDirPath);
      List<String> toplcCommand = new ArrayList<>();
      toplcCommand.addAll(Arrays.asList(
          "toplc", "-s", "-i", inDirPath.toString(), "-o", outDirPath.toString()));
      toplcCommand.addAll(toplProperties);
      ProcessBuilder toplcBuilder = new ProcessBuilder(toplcCommand);
      Process toplc = toplcBuilder.start();
      int result = toplc.waitFor();
      if (result != 0) bail("toplc returned nonzero error code");
    }


    // === Step 3 ===
    try (BufferedReader r = new BufferedReader(new FileReader(javacErr))) {
      System.err.printf("[parsing started RegularFileObject[%s]]\n",
        outDirPath.resolve("topl").resolve("Property.java"));
      System.err.printf("[wrote RegularFileObject[%s]]\n",
        outDirPath.resolve("topl").resolve("Property.class"));
      while (true) {
        String line = r.readLine();
        if (line == null) break;
        System.err.println(line);
      }
    }
  }

  static List<String> expandArgFile(String... xs) throws IOException {
    List<String> ys = new ArrayList<>();
    for (String a : xs) {
      if (a.startsWith("@")) {
        // FIXME: Proper parsing? No proper docs, though: See what Javac does.
        // The following code handles what Infer produces now (Jun2017):
        try (BufferedReader br = new BufferedReader(new FileReader(a.substring(1))))
        { while (true) {
            String line = br.readLine();
            if (line == null) break;
            if (line.startsWith("'")) line = line.substring(1, line.length() - 1);
            ys.add(line);
          }
        }
      } else {
        ys.add(a);
      }
    }
    return ys;
  }

  static void bail(String message) {
    System.out.printf("E: %s\n", message);
    System.exit(0);
    // NOTE: If we return an error code, then Infer falls back to javac.
    // The user then has no idea that instrumentation failed.

    // FIXME: There should be some way to fail hard and stop Infer.
  }
}
