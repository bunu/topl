package infer;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/*
Infer can call a custom compiler as long as it is implemented as a jar file,
using the (undocumented?) option --java-jar-compiler. The current class is
intended to be used as a 'compiler' that
  1. calls javac and saves its stdout;
  2. calls toplc to instrument the classes generated by javac; and
  3. prints the stdout produced in step (1) by javac.
*/
public class Compile {
  public static void main(String[] args)
  {
    try { go(args); }
    catch (Exception e) { bail("Exception: " + e); }
  }

  static void go(String[] args) throws IOException, InterruptedException {
    List<String> toplProperties = new ArrayList<>();
    List<String> javacArgs = new ArrayList<>();
    for (String a : args) {
      // FIXME: use some better hack for distinguishing options?
      if (a.endsWith(".topl")) {
        toplProperties.add(a);
      } else {
        javacArgs.add(a);
      }
    }

    String outDirName = getOutDir(javacArgs);
    if (outDirName == null) bail("Please specify the '-d' option for javac.");
    File javacOutput = File.createTempFile("topl", "javac");
    javacOutput.deleteOnExit();

    List<String> javacCommand = new ArrayList<>();
    javacCommand.add("javac");
    javacCommand.addAll(javacArgs);
    ProcessBuilder javacBuilder = new ProcessBuilder(javacCommand);
    javacBuilder.redirectOutput(javacOutput);
    Process javac = javacBuilder.start();
    int result = javac.waitFor();
    if (result != 0) bail("javac returned nonzero error code");

    Path workDir = Files.createTempDirectory("topljavac");
    Path inDirPath = workDir.resolve("original");
    File outDir = new File(outDirName);
    File inDir = inDirPath.toFile();
    if (!(outDir.renameTo(inDir))) bail("Failed to rename classes");
    List<String> toplcCommand = new ArrayList<>();
    toplcCommand.addAll(Arrays.asList(
        "toplc", "-i", inDir.getPath(), "-o", outDir.getPath()));
    toplcCommand.addAll(toplProperties);
    ProcessBuilder toplcBuilder = new ProcessBuilder(toplcCommand);
    Process toplc = toplcBuilder.start();
    result = toplc.waitFor();
    if (result != 0) bail("toplc returned nonzero error code");

    BufferedReader r = new BufferedReader(new FileReader(javacOutput));
    while (true) {
      String line = r.readLine();
      if (line == null) break;
      System.out.println(line);
    }
  }

  static String getOutDir(List<String> args) throws IOException {
    boolean found = false;
    for (String a : args) {
      if (found) return a;
      found |= "-d".equals(a);
      if (a.startsWith("@")) {
        String r = getOutDirFromArgFile(a.substring(1));
        if (r != null) return r;
      }
    }
    return null;
  }

  // FIXME: Infer currently puts args one per line, but the @argFile spec
  // allows arguments to be white-space separated. The code below only
  // understands Infer's current practice.
  static String getOutDirFromArgFile(String fileName) throws IOException {
    BufferedReader br = new BufferedReader(new FileReader(fileName));
    boolean found = false;
    while (true) {
      String line = br.readLine();
      if (line == null) return null;
      if (line.startsWith("'")) line = line.substring(1, line.length() - 1);
      if (found) return line;
      found |= "-d".equals(line);
    }
  }

  static void bail(String message) {
    System.err.printf("E: %s\n", message);
    System.exit(0);
    // NOTE: If we return an error code, then Infer falls back to javac.
    // The user then has no idea that instrumentation failed.

    // FIXME: There should be some way to fail hard and stop Infer.
  }
}
